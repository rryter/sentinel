use std::env;
use std::fs;
use std::io::Write;
use std::path::Path;

const CUSTOM_RULES_DIR: &str = "src/rules/custom";
const GENERATED_FILE: &str = "generated_rules.rs";
const MOD_RS_FILE: &str = "src/rules/custom/mod.rs";

#[derive(Debug)]
struct RuleInfo {
    name: String,
    has_new: bool,
}

fn main() {
    println!("cargo:rerun-if-changed={}", CUSTOM_RULES_DIR);

    // Generate mod.rs file
    generate_mod_rs_file();

    // Generate the rules registration file
    generate_rules_file();
}

fn generate_rules_file() {
    let src_dir = Path::new(CUSTOM_RULES_DIR);
    if !src_dir.exists() || !src_dir.is_dir() {
        return;
    }

    let mut rules = Vec::new();

    if let Ok(entries) = fs::read_dir(src_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Some(file_name) = path.file_stem() {
                    let file_name_str = file_name.to_string_lossy();
                    if file_name_str != "mod" {
                        if let Ok(content) = fs::read_to_string(&path) {
                            if let Some(rule_info) = extract_rule_struct_name(&content) {
                                rules.push(rule_info);
                            }
                        }
                    }
                }
            }
        }
    }

    // Sort rules for consistency
    rules.sort_by(|a, b| a.name.cmp(&b.name));

    // Generate the rules file
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join(GENERATED_FILE);
    let mut file = fs::File::create(&dest_path).expect("Failed to create generated file");

    writeln!(
        file,
        "// This file is automatically generated by build.rs. DO NOT EDIT!"
    )
    .unwrap();
    writeln!(file).unwrap();

    // Import all rules
    writeln!(file, "use crate::rules::custom::{{").unwrap();
    for rule in &rules {
        writeln!(file, "    {},", rule.name).unwrap();
    }
    writeln!(file, "}};").unwrap();
    writeln!(file).unwrap();

    // Write the registration function
    writeln!(
        file,
        "pub(crate) fn register_rules(registry: &mut crate::rules_registry::RulesRegistry) {{"
    )
    .unwrap();

    // Register each rule
    for rule in &rules {
        writeln!(
            file,
            "    registry.register_rule(Box::new({}{}));",
            rule.name,
            if rule.has_new { "::new()" } else { "" }
        )
        .unwrap();
    }

    writeln!(file, "}}").unwrap();
}

fn generate_mod_rs_file() {
    let src_dir = Path::new(CUSTOM_RULES_DIR);
    if !src_dir.exists() || !src_dir.is_dir() {
        return;
    }

    let mut module_declarations = Vec::new();
    let mut re_exports = Vec::new();

    if let Ok(entries) = fs::read_dir(src_dir) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_file() && path.extension().map_or(false, |ext| ext == "rs") {
                if let Some(file_name) = path.file_stem() {
                    let file_name_str = file_name.to_string_lossy();
                    if file_name_str != "mod" {
                        let module_name = file_name_str.to_string();
                        if let Ok(content) = fs::read_to_string(&path) {
                            if let Some(rule_info) = extract_rule_struct_name(&content) {
                                module_declarations.push(format!("pub mod {};", module_name));
                                re_exports
                                    .push(format!("pub use {}::{};", module_name, rule_info.name));
                            }
                        }
                    }
                }
            }
        }
    }

    // Sort declarations and exports for consistency
    module_declarations.sort();
    re_exports.sort();

    // Read existing file to preserve any custom code
    let existing_content = fs::read_to_string(MOD_RS_FILE).unwrap_or_default();
    let custom_code = extract_custom_code(&existing_content);

    // Write the new content
    let mut content = String::new();

    // Add any imports from custom code
    if let Some(imports) = custom_code.get("imports") {
        content.push_str(imports);
        content.push_str("\n\n");
    }

    content.push_str("// Module declarations for custom rules\n");
    content.push_str(&module_declarations.join("\n"));
    content.push_str("\n\n// Re-export custom rules\n");
    content.push_str(&re_exports.join("\n"));

    // Add any remaining custom code
    if let Some(remaining) = custom_code.get("remaining") {
        content.push_str("\n\n");
        content.push_str(remaining);
    }

    fs::write(MOD_RS_FILE, content).expect("Failed to write mod.rs");
}

fn extract_rule_struct_name(content: &str) -> Option<RuleInfo> {
    for line in content.lines() {
        if line.contains("pub struct") && line.contains("Rule") {
            let struct_name = line
                .split_whitespace()
                .find(|word| word.contains("Rule"))
                .map(|s| s.trim_matches(|c: char| !c.is_alphanumeric()).to_string())?;

            // Check if the struct has a new() function
            let has_new = content.contains(&format!("impl {} {{", struct_name))
                && content.contains("pub fn new(");

            return Some(RuleInfo {
                name: struct_name,
                has_new,
            });
        }
    }
    None
}

fn extract_custom_code(content: &str) -> std::collections::HashMap<&str, String> {
    let mut parts = std::collections::HashMap::new();
    let mut imports = Vec::new();
    let mut remaining = Vec::new();
    let mut in_custom_section = true;

    for line in content.lines() {
        if line.starts_with("pub mod ") || line.starts_with("pub use ") {
            in_custom_section = false;
            continue;
        }

        if in_custom_section {
            if line.starts_with("use ") {
                imports.push(line);
            } else if !line.trim().is_empty() {
                remaining.push(line);
            }
        } else if !line.starts_with("//") && !line.trim().is_empty() {
            remaining.push(line);
        }
    }

    if !imports.is_empty() {
        parts.insert("imports", imports.join("\n"));
    }
    if !remaining.is_empty() {
        parts.insert("remaining", remaining.join("\n"));
    }

    parts
}
