use std::env;
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

const CUSTOM_RULES_DIR: &str = "src/rules/custom";
const GENERATED_FILE: &str = "custom_rules_discovery.rs";

// Represents a discovered module or file containing rules
#[derive(Debug)]
enum DiscoveryItem {
    Module { name: String, children: Vec<DiscoveryItem> },
    RuleFile { name: String, path: PathBuf, factory_fns: Vec<String> },
}

fn main() {
    println!("cargo:rerun-if-changed={}", CUSTOM_RULES_DIR);

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join(GENERATED_FILE);
    let mut file = fs::File::create(&dest_path).expect("Failed to create generated file");

    writeln!(file, "// Automatically generated by build.rs. DO NOT EDIT.").unwrap();

    let src_dir = Path::new(CUSTOM_RULES_DIR);
    if src_dir.exists() {
        let discovery_tree = discover_rules(src_dir);
        let mut all_factories = Vec::new();

        // Generate nested module structure
        generate_mod_code(&mut file, &discovery_tree, "", &mut all_factories);

        // Generate the factory collection function
        writeln!(file, "\npub fn get_discovered_rule_factories() -> Vec<RuleFactory> {{").unwrap();
        writeln!(file, "    vec![").unwrap();
        for factory_path in all_factories {
            writeln!(file, "        {},", factory_path).unwrap();
        }
        writeln!(file, "    ]").unwrap();
        writeln!(file, "}}").unwrap();

    } else {
        println!("cargo:warning=Custom rules directory '{}' not found.", CUSTOM_RULES_DIR);
        // Generate empty function if dir doesn't exist
        writeln!(file, "\npub fn get_discovered_rule_factories() -> Vec<RuleFactory> {{ vec![] }}").unwrap();
    }
}

// Recursively discovers rules and directory structure
fn discover_rules(dir_path: &Path) -> Vec<DiscoveryItem> {
    let mut items = Vec::new();

    if !dir_path.exists() || !dir_path.is_dir() {
        return items;
    }

    if let Ok(entries) = fs::read_dir(dir_path) {
        for entry_result in entries {
            if let Ok(entry) = entry_result {
                let path = entry.path();
                let file_name = entry.file_name();
                let name_str = file_name.to_string_lossy();

                if path.is_dir() {
                    // Skip hidden/target dirs
                    if !name_str.starts_with('.') && name_str != "target" {
                        let children = discover_rules(&path);
                        if !children.is_empty() {
                            items.push(DiscoveryItem::Module {
                                name: name_str.to_string(),
                                children,
                            });
                        }
                    }
                } else if path.is_file() && name_str.ends_with(".rs") && name_str != "mod.rs" {
                    let module_name = name_str.trim_end_matches(".rs").to_string();
                    if let Ok(content) = fs::read_to_string(&path) {
                        let factories = extract_factory_names(&content);
                        if !factories.is_empty() {
                            // println!("cargo:warning=Found factories {:?} in {}", factories, path.display());
                            items.push(DiscoveryItem::RuleFile {
                                name: module_name,
                                path: path.clone(),
                                factory_fns: factories,
                            });
                        }
                    }
                }
            }
        }
    }
    items
}

// Generates the nested `mod` structure code
fn generate_mod_code(
    file: &mut fs::File,
    items: &[DiscoveryItem],
    current_mod_path: &str,
    all_factories: &mut Vec<String>,
) {
    for item in items {
        match item {
            DiscoveryItem::Module { name, children } => {
                // Don't use #[path] here, rely on standard mod discovery
                // Need mod.rs in the source directory for this module
                 // Check if a mod.rs exists for this directory
                let mod_file_path = Path::new(CUSTOM_RULES_DIR).join(current_mod_path).join(name).join("mod.rs");
                let src_mod_path = if current_mod_path.is_empty() {
                    name.clone()
                } else {
                    format!("{}::{}", current_mod_path, name)
                };

                // Only declare mod if mod.rs exists or it contains rule files/submodules
                if mod_file_path.exists() || !children.is_empty() {
                     writeln!(file, "pub mod {} {{", name).unwrap();
                    generate_mod_code(file, children, &src_mod_path, all_factories);
                    writeln!(file, "}}").unwrap();
                } else {
                     println!("cargo:warning=Skipping module declaration for '{}' as no mod.rs or nested rules found.", src_mod_path);
                }
            }
            DiscoveryItem::RuleFile { name, path, factory_fns } => {
                // Use an absolute path for #[path] based on the CARGO_MANIFEST_DIR
                let absolute_path = Path::new(&env::var("CARGO_MANIFEST_DIR").unwrap()).join(path);
                writeln!(file, "#[path=\"{}\"] pub mod {};", absolute_path.display(), name).unwrap();
                // Add the fully qualified factory function paths
                let base_path = if current_mod_path.is_empty() {
                    format!("{}", name)
                } else {
                    format!("{}::{}", current_mod_path, name)
                };
                for factory_fn in factory_fns {
                    all_factories.push(format!("{}::{}", base_path, factory_fn));
                }
            }
        }
    }
}

// Extracts potential `create_*_rule` function names from file content
fn extract_factory_names(content: &str) -> Vec<String> {
    let mut names = Vec::new();
    // Very basic search - could be improved with regex or syn
    for line in content.lines() {
        if line.contains("fn create_") && line.contains("Rule") && line.contains("-> Arc<dyn Rule>") {
             if let Some(fn_pos) = line.find("fn create_") {
                 let start = fn_pos + 3; // Skip "fn "
                 if let Some(paren_pos) = line[start..].find('(') {
                     let name = line[start..start + paren_pos].trim();
                    if !name.is_empty() {
                         names.push(name.to_string());
                    }
                 }
             }
        }
    }
    names
} 