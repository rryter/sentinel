use std::collections::HashMap;
use std::sync::Arc;
use anyhow::Result;
use crate::rules::{RulePlugin, RuleFactory};

// Include the code generated by build.rs
// This will define the module structure and the `get_discovered_rule_factories` function.
include!(concat!(env!("OUT_DIR"), "/custom_rules_discovery.rs"));

// Use a thread-safe mechanism for the registry
use once_cell::sync::Lazy;
use std::sync::Mutex;

static CUSTOM_RULE_REGISTRY: Lazy<Mutex<HashMap<String, RuleFactory>>> = Lazy::new(|| Mutex::new(HashMap::new()));

/// Register a custom rule factory function (intended for build script)
/// Note: This is slightly different now; the build script will generate calls
/// that directly insert into the registry.
pub fn register_factory_fn(rule_id: String, factory: RuleFactory) {
    let mut registry = CUSTOM_RULE_REGISTRY.lock().unwrap();
    registry.insert(rule_id, factory);
}

/// Initialize the custom rules system by running the generated registration code
pub fn initialize() {
    // Add any non-rule-discovery initialization here if necessary
    println!("Custom rules module initialized.");
}

/// Get all registered custom rule factories
pub fn get_custom_rule_factories() -> Vec<RuleFactory> {
    let registry = CUSTOM_RULE_REGISTRY.lock().unwrap();
    registry.values().cloned().collect()
}

/// Load all custom rule plugins by collecting factories from the generated code
pub fn get_all_custom_plugins() -> Result<Vec<RulePlugin>> {
    // Get the factories discovered and listed by the build script
    let factories = get_discovered_rule_factories();

    if factories.is_empty() {
        println!("No custom rules discovered.");
        return Ok(Vec::new());
    }

    // Group all discovered custom rules into a single plugin
    let custom_plugin = RulePlugin {
        name: "custom-rules".to_string(),
        description: "Custom rules discovered at build time".to_string(),
        rules: factories, // Directly use the Vec<RuleFactory>
    };

    Ok(vec![custom_plugin])
} 